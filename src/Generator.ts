import { Document, HttpMethod, Normalized, Paths } from '@/interfaces.ts';
import Normalize from '@/Normalization.ts';
import FileSystemInteraction from './FileSystemInteraction.ts';

/** Attribution comment included in generated files */
const tribute: string[] = [
  '/*\n',
  ' ** ------------------------------------------ **\n',
  ' ** This file was generated by @omar-labana/ez **\n',
  ' ** @source: https://github.com/omar-labana/ez **\n',
  ' ** ------------------------------------------ **\n',
  ' */\n\n',
  `import type { FetchOptions } from 'ofetch';\n\n`,
];

const fetchInstance = 'const factoryFetch = useFactoryFetch();\n';

/**
 * Generator class responsible for organizing operations by tags and generating repository files
 */
class Generator {
  normalize: Normalize;
  fileSystemInteraction: FileSystemInteraction;
  map = new Map<string, Paths[]>([['miscellaneous', []]]);

  constructor() {
    this.normalize = new Normalize();
    this.fileSystemInteraction = new FileSystemInteraction();
  }

  /**
   * Prepares the generator by organizing OpenAPI operations by tags
   * @param {Document} document - The OpenAPI document to process
   */
  prepare(document: Document) {
    for (const [path, pathItem] of Object.entries(document.paths)) {
      for (const operation of Object.values(pathItem)) {
        const operationId = operation.operationId;
        // Check if operationId already exists in any of the map's arrays
        let exists = false;
        for (const paths of this.map.values()) {
          if (
            paths.some((obj) => {
              const value = Object.values(obj)[0];
              return Object.values(value).some((op) => op.operationId === operationId);
            })
          ) {
            exists = true;
            break;
          }
        }
        if (exists) continue;

        if (!operation.tags || operation.tags.length === 0) {
          this.map.get('miscellaneous')?.push({ [path]: pathItem });
        } else {
          if (this.map.has(operation.tags[0])) {
            this.map.get(operation.tags[0])?.push({ [path]: pathItem });
          } else {
            this.map.set(operation.tags[0], [{ [path]: pathItem }]);
          }
        }
      }
    }
  }

  /**
   * Conserves (converts) operations for a specific tag into normalized format
   * @param {string} tag - The tag name to process
   * @returns {Normalized} Normalized operations and repository name
   */
  conserve(tag: string): Normalized {
    const nameRepository = this.normalize.nameRepository(tag);
    const normalized: Normalized = {
      repository: nameRepository,
      operations: [],
    };

    const paths = this.map.get(tag) || [];
    for (const pathObj of paths) {
      const [key, value] = Object.entries(pathObj)[0];

      for (const [operationKey, operationValue] of Object.entries(value)) {
        normalized.operations.push({
          method: operationKey as HttpMethod,
          path: key,
          summary: operationValue.summary || '',
          description: operationValue.description || '',
          function: this.normalize.nameRequest(operationKey, key),
          operationId: operationValue.operationId || '',
          payload: '' +
            (operationKey === 'get'
              ? '{}'
              : operationValue.operationId
              ? operationValue.operationId + 'Request'
              : 'unknown'),
          returns:
            operationValue.responses?.['200']?.content?.['application/json']?.schema?.$ref?.replace(
              '#/components/schemas/',
              '',
            ) || 'unknown',
          parameters: operationValue.parameters || [],
          requestBody: operationValue.requestBody,
        });
      }
    }

    return normalized;
  }

  /**
   * Generates all repository files from the prepared operations
   */
  generate() {
    for (const tag of this.map.keys()) {
      const normalized = this.conserve(tag);
      const start = tribute.join('');

      const constFunctions = normalized.operations.map((operation) => {
        return `const ${operation.function} = (${
          this.normalize.functionArguments(operation)
        }, options?: FetchOptions) => factoryFetch<${operation.returns || 'unknown'}>(${
          this.normalize.endpoint(operation.path)
        }, {...options, ${
          operation.method === 'get' ? 'query' : 'body'
        },\nmethod: '${operation.method}'})\n\n`;
      }).join('');

      const returnValue = `{\n${
        normalized.operations.map((operation) => {
          return `  ${operation.function},\n`;
        }).join('')
      }}`;

      const functionDefinition =
        `const ${normalized.repository} = () => {\n  ${fetchInstance}\n${constFunctions}\nreturn ${returnValue}\n};\n\nexport default ${normalized.repository};\n`;

      this.fileSystemInteraction.writeRepository(
        normalized.repository,
        start + functionDefinition,
      );
    }
  }
}

export default Generator;
